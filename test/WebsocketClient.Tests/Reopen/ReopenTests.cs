using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using Moq;
using Shouldly;
using Websocket.Client.Events;
using Xunit;
using Xunit.Abstractions;

// using Divergic.Logging.Xunit;

namespace Websocket.Client.Reopen
{
    public class ReopenTests
    {
        public ReopenTests(ITestOutputHelper testOutputHelper)
        {
            _logger = testOutputHelper.BuildLogger();
        }

        private readonly ILogger _logger;

        [Fact]
        public async void auto_reopen_throttle_test()
        {
            var liteClient = new Mock<IWebsocketLiteClient>();
            var mock = new Mock<TestWebsocketClient>(liteClient.Object, _logger)
            {
                CallBase = true
            };

            mock.Object.AutoReopenOnKeepAliveTimeout = true;
            mock.Object.KeepAliveTimeout = TimeSpan.FromSeconds(0.5);
            mock.Object.AutoReopenThrottleTimeSpan = TimeSpan.FromSeconds(3);

            var reopenTimes = new List<DateTimeOffset>();
            var reopenEvent = new AutoResetEvent(false);
            mock.Setup(c => c.TryReopenAsyncInternal())
                .CallBase()
                .Callback(() =>
                {
                    reopenTimes.Add(DateTimeOffset.UtcNow);
                    reopenEvent.Set();
                });

            await mock.Object.OpenAsync();
            mock.Object.State.ShouldBe(ReadyState.Open);

            reopenEvent.WaitOne(2000).ShouldBeTrue();
            mock.Object.State.ShouldBe(ReadyState.Open);

            reopenEvent.WaitOne(4000).ShouldBeTrue();
            (reopenTimes[1] - reopenTimes[0] >= TimeSpan.FromSeconds(3)).ShouldBeTrue();
        }


        [Fact]
        public async Task auto_reopen_when_closed_test()
        {
            //arrange
            var liteClient = new Mock<IWebsocketLiteClient>();
            var mock = new Mock<TestWebsocketClient>(liteClient.Object, _logger)
            {
                CallBase = true
            };

            mock.Object.AutoReopenOnClosed = true;

            var reopenEvent = new AutoResetEvent(false);
            mock.Setup(c => c.TryReopenAsyncInternal())
                .CallBase()
                .Callback(() => reopenEvent.Set());

            await mock.Object.OpenAsync();
            liteClient.Raise(client => client.Closed += null,
                new CloseEventArgs(CloseStatusCode.Normal, "test close1"));
            mock.Object.State.ShouldBe(ReadyState.Closed);

            //assert
            reopenEvent.WaitOne(1200).ShouldBeTrue();
            await Task.Delay(100);
            mock.Object.State.ShouldBe(ReadyState.Open);
        }

        [Fact]
        public async Task auto_reopen_when_keep_live_timeout_test()
        {
            //arrange
            var liteClient = new Mock<IWebsocketLiteClient>();
            var mock = new Mock<TestWebsocketClient>(liteClient.Object, _logger)
            {
                CallBase = true
            };

            mock.Object.AutoReopenOnKeepAliveTimeout = true;
            mock.Object.KeepAliveTimeout = TimeSpan.FromSeconds(0.5);

            var reopenEvent = new AutoResetEvent(false);
            mock.Setup(c => c.TryReopenAsyncInternal())
                .CallBase()
                .Callback(() => reopenEvent.Set());

            await mock.Object.OpenAsync();
            mock.Object.State.ShouldBe(ReadyState.Open);

            //assert
            reopenEvent.WaitOne(1200).ShouldBeTrue();
            await Task.Delay(100);
            mock.Object.State.ShouldBe(ReadyState.Open);
        }
    }
}